---
title: 【JavaScript】执行环境
date: 2019-11-20
categories:
    - JavaScript
tags:
    - JavaScript
    - 前端
---

# 执行环境

日常生活中的环境是指以某物为中心点，周围的空间事物等称为环境，那么顾名思义 这里的执行环境（execution context）也就是代码在执行时所处的环境，在 Javascript 中每一个函数中都是一个环境。

## 变量对象

每一个环境都有一个与之相关联的变量对象 (variable object)，这个变量对象中存放着这个环境中所有定义的变量和函数，
Javascript 代码访问不到变量对象，但它在后台会被解析器使用，最外层的执行环境也就是全局执行环境的变量对象被认为是 window 因为全局环境中所有的变量和函数都是 window 的属性和方法定义的，每一个函数都有一个自己的环境，而函数的中的变量对象则用函数的活动对象(activation object)来代替，活动对象中一开始只有一个变量，arguments 对象,arguments 对象中存放了这个函数的所有参数，执行环境中的代码执行完毕后会被销毁,环境中的对象也随之销毁，除了全局执行环境是在关闭标签页或者浏览器才会销毁

```js
let obj = {}
let arr = []
function fun() {
    console.log(...arguments)
}
function callback() {}
fun(1, obj, arr, callback) // 1 {} []  callback(){}
```

## 作用域

作用域 (scope) 是指代码可作用的范围，作用域一般分为两种，一种是词法作用域，也就是静态作用域，另一种则是动态作用域，Javascript 中的作用域属于前者，函数环境的作用域在定义时就定好了，所以 Javascript 的函数只注重声明的地方，而不在乎调用的地方

## 作用域链

作用域链(scope chain) ,指的是所处环境的能访问到的变量对象串联起来形成的链条，保证了有序的查找变量和函数，
当函数被调用的时候会创建该函数的环境和一个与之对应的作用域链，该函数的变量对象用函数的活动对象来代替，当访问变量时先从该函数变量对象上查找，如果找不到再往上一层作用域链环境的变量对象中查找，直到最外层的变量对象也找不到就返回 undefined

```js
let a = 1
let b = 2
function fn1() {
    let a = 3
    console.log(a, b, c)
}
fn1() //  3 2 undefined
```

## 执行栈

栈 (stack) 是一种后进先出的数据结构 , Call Stack (调用栈) (执行栈) 也是如此,当 JavaScript 引擎执行到 Javascript 代码时会创建第一个环境，也就是全局环境 ，压入执行栈中 , 之后每当遇到函数调用就会把当前函数的环境压入栈顶， 引擎会先执行位于栈顶的函数，当栈顶函数执行完毕后弹出调用栈，引擎开始执行下一个栈顶函数的上下文，如下抽象代码

```js
//  create ECStack
function fn1() {
    console.log(1)
}
function fn2() {
    console.log(2)
}
function fn3() {
    fn2()
    console.log(3)
}
// 将 fn1 的环境压入执行栈中开始执行,执行完 console.log(1) 后弹出并销毁fn1的环境
fn1()
// 将 fn3 的环境压入执行栈中开始执行, 遇到调用 fn2 先将 fn2 的环境压入执行栈顶，先执行fn2。
// 当 fn2 中的代码也就是 console.log(2) 执行完毕后弹出并销毁fn2的环境，开始执行 fn3 中下面的代码
fn3()
//  log 结果 1 2 3
// 继续执栈顶的环境
```

## 闭包

闭包是一个老生常谈的问题,闭包到底是什么呢？

> 闭包是指有权访问另一个函数作用域中的变量的函数 ——《JavaScript 高级程序设计第三版》

在上面我们讲到[作用域链](#作用域链)，当函数被调用的时候会创建该函数的环境和一个与之对应的作用域链，而当环境中所有代码执行完成后会销毁环境，包括变量对象，而闭包函数的外部函数环境，和变量是不会被销毁的是会留在内存当中的！

```js
function fn1(a) {
    return function(b) {
        return a + b
    }
}
let fn2 = fn1(1)
fn2(1) // 2
```

在上列代码中，fn1 函数已经执行完毕了，但是它的环境并没有被销毁，因为返回的匿名函数中的作用域链引用到了外部函数的变量对象,所以保留在了内存当中不被引擎销毁
